//Code Adapted from http://bl.ocks.org/d3noob/8375092 (author: Malcolm Maclean), which is itself an adaptation of https://bl.ocks.org/mbostock/4339083 (author: Mike Bostock)
//This is released under the GNU public license v3: https://opensource.org/licenses/GPL-3.0




var margin = {top: 30, right: 120, bottom: 20, left: 120},
	//Width = 960 OR the width of the div
	width = Math.min((document.getElementById('graph-section').offsetWidth - margin.right - margin.left),(960 - margin.right - margin.left)),
	//Height = 500
	height = 500 - margin.top - margin.bottom;

var i = 0,
duration = 750,
root;

limits = {x : [-100, 100], y : [-100, 100]}

//Fix NodeSize to space nodes properly
var tree = d3.layout.tree()
	.nodeSize([200,200]);

var diagonal = d3.svg.diagonal()
	.projection(function(d) { return [d.x, d.y]; });

var svg = d3.select("#graph-section").append("svg")
	.attr("id","graph_svg")
	.attr("style", "background:white;outline: thin solid gray;")
	.attr("width", width + margin.right + margin.left)
	.attr("height", height + margin.top + margin.bottom)
	pg = svg.append("g")
		.attr("transform", "translate(" + (width+margin.right+margin.left)/2 + "," + margin.top + ")");

var mid_x = (width+margin.right+margin.left)/2
var mid_y = (margin.top)


var zoom_func = d3.behavior.zoom()
	.scaleExtent([.5,10])
	.translate([mid_x,mid_y])
	.on("zoom",function(){
		t_tr = d3.event.translate;
		t_sc = d3.event.scale;
		tr_x = t_tr[0];
		tr_y = t_tr[1];
		gp = 200 * t_sc
		if (t_tr[0] - mid_x >= 0){
			tr_x = Math.min(limits.x[1]*t_sc + (mid_x) + gp, t_tr[0]);
		}if (t_tr[0] - mid_x < 0){
			tr_x = Math.max(limits.x[0]*t_sc + (mid_x) - gp, t_tr[0]);
		}if (t_tr[1] >= 0){
			tr_y = Math.min((limits.y[1]+mid_y)*t_sc,t_tr[1]);
		}if (t_tr[1] < 0){
			tr_y = Math.max((limits.y[0]+mid_y)*t_sc,t_tr[1]);
		}
		zoom_func.translate([tr_x,tr_y]);
		pg.attr("transform",[
			"translate("+ [tr_x,tr_y] + ")",
			"scale(" + t_sc + ")"
		].join(" "));
	});

svg.call(zoom_func);


root = treeData[0];
root.x0 = height / 2;
root.y0 = 0;
  
update(root);

var d3tables = { d3xs : [], d3ys : [] };

function get_xy(d3tables){
	d3.selectAll('g.node')
	.each(function(d) {
		d3tables.d3xs.push(d.x);
		d3tables.d3ys.push(d.y);
	});
}

get_xy(d3tables);

max_x = Math.max.apply(Math,d3tables.d3xs)
min_x = Math.min.apply(Math,d3tables.d3xs)

max_y = Math.max.apply(Math,d3tables.d3ys) + mid_y
min_y = Math.min.apply(Math,d3tables.d3ys) + mid_y

limits.x[0] = -((max_x))
limits.x[1] = -((min_x))
//max_y is actually the lower bound. Need to negate to match svg coordinate plane
limits.y[0] = -(max_y);
//min_y == 0 always
limits.y[1] = (min_y) + 100;

d3.select(self.frameElement).style("height", "500px");

function update(source) {
	  // Compute the new tree layout.
	  var nodes = tree.nodes(root).reverse(),
		  links = tree.links(nodes);

	  // Normalize for fixed-depth.
	  nodes.forEach(function(d) { d.y = d.depth * 100; });

	  // Update the nodesâ€¦
	  var node = pg.selectAll("g.node")
		  .data(nodes, function(d) { return d.id || (d.id = ++i); }); 

	  // Enter any new nodes at the parent's previous position.
	  var nodeEnter = node.enter().append("g")
		  .attr("class", "node")
		  .attr("transform", function(d) { return "translate(" + source.x0 + "," + source.y0 + ")"; })
		  .on("click", click);

	  nodeEnter.append("circle")
		  .attr("r", 1e-6)
		  .style("fill", function(d) { return d._children ? "red" : "#fff"; });

	  nodeEnter.append("text")
		  .attr("y", function(d) { return d.children || d._children ? -25 : 25; })
//		  .attr("transform",function(d){ return "rotate(" + (d.children || d._children ? "0" : "90") + ")";})
		  .attr("dy", ".35em")
		  .attr("text-anchor", function(d) { return d.children || d._children ? "middle" : "middle"; })
		  .text(function(d) { return d.name; })
		  .style("fill-opacity", 1e-6);

	  // Transition nodes to their new position.
	  var nodeUpdate = node.transition()
		  .duration(duration)
		  .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

	  nodeUpdate.select("circle")
		  .attr("r", 16)
		  .style("fill", function(d) { return d._children ? "red" : "#fff"; });

	  nodeUpdate.select("text")
		  .style("fill-opacity", 1);

	  // Transition exiting nodes to the parent's new position.
	  var nodeExit = node.exit().transition()
		  .duration(duration)
		  .attr("transform", function(d) { return "translate(" + source.x + "," + source.y + ")"; })
		  .remove();

	  nodeExit.select("circle")
		  .attr("r", 1e-6);

	  nodeExit.select("text")
		  .style("fill-opacity", 1e-6);

	  // Update the linksâ€¦
	  var link = pg.selectAll("path.link")
		  .data(links, function(d) { return d.target.id; });

	  // Enter any new links at the parent's previous position.
	  link.enter().insert("path", "g")
		  .attr("class", "link")
		  .attr("d", function(d) {
			var o = {x: source.x0, y: source.y0};
			return diagonal({source: o, target: o});
		  });

	  // Transition links to their new position.
	  link.transition()
		  .duration(duration)
		  .attr("d", diagonal);

	  // Transition exiting nodes to the parent's new position.
	  link.exit().transition()
		  .duration(duration)
		  .attr("d", function(d) {
			var o = {x: source.x, y: source.y};
			return diagonal({source: o, target: o});
		  })
		  .remove();

	  // Stash the old positions for transition.
	  nodes.forEach(function(d) {
		d.x0 = d.x;
		d.y0 = d.y;
	  });

}

// Toggle children on click.
function click(d) {
  if (d.children) {
	d._children = d.children;
	d.children = null;
  } else {
	d.children = d._children;
	d._children = null;
  }
  update(d);
}
