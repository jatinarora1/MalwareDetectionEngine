#!/usr/bin/env python
# Copyright (C) 2010-2013 Claudio Guarnieri.
# Copyright (C) 2014-2016 Cuckoo Foundation.
# This file is part of Cuckoo Sandbox - http://www.cuckoosandbox.org
# See the file 'docs/LICENSE' for copying permission.

import random
import logging
import sys
import psutil
import time

from threading import Thread
from ctypes import WINFUNCTYPE, POINTER
from ctypes import c_bool, c_int, create_unicode_buffer,c_ulong,byref

from lib.common.abstracts import Auxiliary
from lib.common.defines import KERNEL32, USER32
from lib.common.defines import WM_GETTEXT, WM_GETTEXTLENGTH, BM_CLICK

log = logging.getLogger(__name__)

EnumWindowsProc = WINFUNCTYPE(c_bool, POINTER(c_int), POINTER(c_int))
EnumChildProc = WINFUNCTYPE(c_bool, POINTER(c_int), POINTER(c_int))


PidTabVal = { }

def get_tab_val(pid):
	if not pid in PidTabVal:
		PidTabVal[pid]=1
	
	return PidTabVal[pid]


def update_tab_val(pid):
	if not pid in PidTabVal:
		PidTabVal[pid]=0

	PidTabVal[pid]=PidTabVal[pid]+1
	return PidTabVal[pid]
	


default_action_win = ["bosa_sdm_"]

RESOLUTION = {
    "x": USER32.GetSystemMetrics(0),
    "y": USER32.GetSystemMetrics(1)
}

def type_keyboard(key_value,scan_value):
        USER32.keybd_event(key_value,scan_value,0,0)
        USER32.keybd_event(key_value,scan_value,0x0002,0)
        KERNEL32.Sleep(80)


def foreach_child(hwnd, lparam):
    # List of buttons labels to click.
    buttons = [
        "yes", "oui",
        "ok",
        "accept", "accepter",
        "next", "suivant",
        "install", "installer",
        "run",
        "agree", "j'accepte",
        "enable", "activer",
        "don't send", "ne pas envoyer",
        "don't save",
        "continue", "continuer",
        "unzip", "dezip",
        "open", "ouvrir",
        "close the program",
        "later",
        "finish",
        "end",
	"allow",
        "allow access",
        "execute", "executer",
        "launch", "lancer",
        "save", "sauvegarder"
    ]

    # List of buttons labels to not click.
    dontclick = [
        "don't run",
	"do not open",
	"block",
    ]

    classname = create_unicode_buffer(50)
    USER32.GetClassNameW(hwnd, classname, 50)

    # Check if the class of the child is button.
    if "button" in classname.value.lower():
        # Get the text of the button.
        length = USER32.SendMessageW(hwnd, WM_GETTEXTLENGTH, 0, 0)
        text = create_unicode_buffer(length + 1)
	
	USER32.SetActiveWindow(hwnd)
	USER32.SetForegroundWindow(hwnd)        
	
	USER32.SendMessageW(hwnd, WM_GETTEXT, length + 1, text)
	
	#log.info(text.value)	
			
	USER32.SetActiveWindow(hwnd)
	USER32.SetForegroundWindow(hwnd)	

        # Check if the button is set as "clickable" and click it.
        textval = text.value.replace("&", "").lower()
        for button in buttons:
            if button in textval:
                for btn in dontclick:
                    if btn in textval:
                        break
                else:
                    log.info("Found button \"%s\", clicking it" % text.value)
                    USER32.SetForegroundWindow(hwnd)
                    KERNEL32.Sleep(1000)
                    USER32.SendMessageW(hwnd, BM_CLICK, 0, 0)

    # Recursively search for childs (USER32.EnumChildWindows).
    return True

# Callback procedure invoked for every enumerated window.
def foreach_window(hwnd, lparam):
    # If the window is visible, enumerate its child objects, looking
    # for buttons.
	
    if USER32.IsWindowVisible(hwnd):
        classname = create_unicode_buffer(50)
        USER32.GetClassNameW(hwnd, classname, 50)

        # If the window is one of the known class types that are inaccessible by User32, send Enter
        # This may proceed if there is a default action
        for win in default_action_win:
                if win in classname.value.lower():
                        log.info("Found inaccessible window of class %s. Sending Enter" % classname.value.lower())
	                USER32.SetActiveWindow(hwnd)
	                USER32.SetForegroundWindow(hwnd)
	                type_keyboard(0x09,0x8F)
                        type_keyboard(0x0D,0x9C)

        USER32.EnumChildWindows(hwnd, EnumChildProc(foreach_child), 0)
	

	#Turning off the ability of pressing objects in PDF, URL is good enough
	#try:
		#Get PID of current window
	#	win_pid = c_ulong(0)
	#	USER32.GetWindowThreadProcessId(hwnd,byref(win_pid))

		#Get application name from PID
	#	procname = psutil.Process(win_pid.value)
	#	applicname = procname.name()
	
	#	tabVal = get_tab_val(win_pid.value)

		#If this is PDF
	#	if "AcroRd" in applicname:
	#		log.info("App Name %s",applicname)
	#		log.info("TabValue: %s",str(tabVal))
	#		USER32.SetActiveWindow(hwnd)
	#	        USER32.SetForegroundWindow(hwnd)
	#		log.info("Sending Tab and Enter")
			#We are sending Tab different number of times
			# to cover different URLs
			#for y in range(0,tabVal):
			#	#Sending Tab
			#	type_keyboard(0x09,0x0F)
			#	time.sleep(0.1)
			#Sending Enter
			#type_keyboard(0x0D,0x1C)
			#time.sleep(10)
			#update_tab_val(win_pid.value)

	#except:
	#	log.info("Raised exception")	
	#	e = sys.exc_info()[0]
	#       log.info(str(e))
        #        e1 = sys.exc_info()[1]
        #        log.info(str(e1))
	
    return True

def move_mouse():
    x = random.randint(0, RESOLUTION["x"])
    y = random.randint(0, RESOLUTION["y"])

    # Originally was:
    # USER32.mouse_event(0x8000, x, y, 0, None)
    # Changed to SetCurorPos, since using GetCursorPos would not detect
    # the mouse events. This actually moves the cursor around which might
    # cause some unintended activity on the desktop. We might want to make
    # this featur optional.
    USER32.SetCursorPos(x, y)

def click_mouse():
    # Move mouse to top-middle position.
    USER32.SetCursorPos(RESOLUTION["x"] / 2, 0)
    # Mouse down.
    USER32.mouse_event(2, 0, 0, 0, None)
    KERNEL32.Sleep(50)
    # Mouse up.
    USER32.mouse_event(4, 0, 0, 0, None)

class Human(Auxiliary, Thread):
    """Human after all"""

    def __init__(self, options={}, analyzer=None):
        Thread.__init__(self)
        Auxiliary.__init__(self, options, analyzer)
        self.do_run = True
	#self.do_run = False

    def stop(self):
        self.do_run = False

    def run(self):
        # Global disable flag.
        if "human" in self.options:
            self.do_move_mouse = int(self.options["human"])
            self.do_click_mouse = int(self.options["human"])
            self.do_click_buttons = int(self.options["human"])
        else:
            self.do_move_mouse = True
            self.do_click_mouse = True
            self.do_click_buttons = True

        # Per-feature enable or disable flag.
        if "human.move_mouse" in self.options:
            self.do_move_mouse = int(self.options["human.move_mouse"])

        if "human.click_mouse" in self.options:
            self.do_click_mouse = int(self.options["human.click_mouse"])

        if "human.click_buttons" in self.options:
            self.do_click_buttons = int(self.options["human.click_buttons"])

        while self.do_run:
            if self.do_click_mouse:
                click_mouse()

            if self.do_move_mouse:
                move_mouse()

            if self.do_click_buttons:
                USER32.EnumWindows(EnumWindowsProc(foreach_window),0)

            KERNEL32.Sleep(1000)
