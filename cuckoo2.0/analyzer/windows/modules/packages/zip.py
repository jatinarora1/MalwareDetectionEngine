# Copyright (C) 2010-2013 Claudio Guarnieri.
# Copyright (C) 2014-2016 Cuckoo Foundation.
# This file is part of Cuckoo Sandbox - http://www.cuckoosandbox.org
# See the file 'docs/LICENSE' for copying permission.

import os
import shutil
import logging
import subprocess

from lib.core.packages import choose_package

from zipfile import ZipFile, BadZipfile

from lib.common.abstracts import Package
from lib.common.exceptions import CuckooPackageError

log = logging.getLogger(__name__)

#Get file type by running a specific file utility
def get_file_type(filename):
	try:
        	p = subprocess.Popen(["C:\\Dlls\\file.exe", filename,"-m", "C:\\Dlls\\magic.db"],
                                      stdout=subprocess.PIPE)
                file_type = p.stdout.read().strip()
		return file_type
        except Exception as e:
                log.debug("Error running file(1) on %s: %s",
                           filename, e)
		return None


#Run a particular package on current file 
def run_package(zippack,curPack,filename):
	package_name = "modules.packages.%s" %curPack
	try:
		__import__(package_name,globals(),locals(),["dummy"],-1)
		log.warning("Package imported: %s",package_name)
	except ImportError:
		log.warning("Failed to import package %s",package_name)


	# Initialize the package parent abstract.
        Package()

	#numPacks = len(Package.__subclassses__())
	#log.warning("Number of packages %s",numPacks)
	for cls in Package.__subclasses__():		
		#log.warning("Class %s",cls.__name__)
		if str.lower(cls.__name__) in curPack:
			package = cls(zippack.options)

			try:
				log.warning("Starting package %s",cls.__name__)
				package.start(filename)
			except Exception as e:
				log.warning("Failed to start package on file with error %s: %s: %s ",
					    package_name,filename,e)



class Zip(Package):
    """Zip analysis package."""

    def extract_zip(self, zip_path, extract_path, password):
        """Extracts a nested ZIP file.
        @param zip_path: ZIP path
        @param extract_path: where to extract
        @param password: ZIP password
        """
        # Test if zip file contains a file named as itself.
        if self.is_overwritten(zip_path):
            log.debug("ZIP file contains a file with the same name, original is going to be overwrite")
            # TODO: add random string.
            new_zip_path = zip_path + ".old"
            shutil.move(zip_path, new_zip_path)
            zip_path = new_zip_path

        # Extraction.
        with ZipFile(zip_path, "r") as archive:
            try:
                archive.extractall(path=extract_path, pwd=password)
            except BadZipfile:
                raise CuckooPackageError("Invalid Zip file")
            except RuntimeError:
                try:
                    archive.extractall(path=extract_path, pwd="infected")
                except RuntimeError as e:
                    raise CuckooPackageError("Unable to extract Zip file: "
                                             "{0}".format(e))
            finally:
                # Extract nested archives.
                for name in archive.namelist():
                    if name.endswith(".zip"):
                        # Recurse.
                        self.extract_zip(os.path.join(extract_path, name), extract_path, password)

    def is_overwritten(self, zip_path):
        """Checks if the ZIP file contains another file with the same name, so it is going to be overwritten.
        @param zip_path: zip file path
        @return: comparison boolean
        """
        with ZipFile(zip_path, "r") as archive:
            try:
                # Test if zip file contains a file named as itself.
                for name in archive.namelist():
                    if name == os.path.basename(zip_path):
                        return True
                return False
            except BadZipfile:
                raise CuckooPackageError("Invalid Zip file")

    def get_infos(self, zip_path):
        """Get information from ZIP file.
        @param zip_path: zip file path
        @return: ZipInfo class
        """
        try:
            with ZipFile(zip_path, "r") as archive:
                return archive.infolist()
        except BadZipfile:
            raise CuckooPackageError("Invalid Zip file")

    def start(self, path):
	
	log.warning("Starting ZIP")        
	password = self.options.get("password")

        zipinfos = self.get_infos(path)
        self.extract_zip(path, self.curdir, password)

        file_name = self.options.get("file")
        
	#Find package name for each file in extracted version of zip
	numItems = len(zipinfos)
	log.warning("Items %i",numItems)
	index = 0

	pids = []

	#Iterate over each item in this zip, figure our its type and
	#run corresponding analysis package
        while index < numItems:
                tempname = zipinfos[index].filename
                index +=1
                temppath = os.path.join(self.curdir,tempname)
		temppath = os.path.normcase(temppath)
                log.warning("Temp File Name %s",temppath)

		#If it is a directory, we can skip it
		if os.path.isdir(temppath):
			log.warning("Is Directory %s",temppath)
		        continue	

		#Determine its file type
		file_type = get_file_type(temppath)
		if file_type:
			#log.warning("File Type %s",file_type)
			package = choose_package(file_type,temppath,"",temppath)
			log.warning("Package %s",package)
			curpids = run_package(self,package,temppath)
			log.warning("Started package")	
			pids.append(curpids)

	log.warning("Returning PIDS")

	#Lets not return any PID, we will run for full timeout
	return None 
			

	# If no file name is provided via option, take the first file.
        #if not file_name:
            # No name provided try to find a better name.
        #    if len(zipinfos):
        #        # Take the first one.
        #        file_name = zipinfos[0].filename
        #        log.debug("Missing file option, auto executing: {0}".format(file_name))
        #    else:
        #        raise CuckooPackageError("Empty ZIP archive")

        #file_path = os.path.join(self.curdir, file_name)
        #return self.execute(file_path, self.options.get("arguments"))
