#!/usr/bin/env python

import os
import sys
import signal
import argparse
import subprocess


#Open the "null" file. Used for the Popen commands
null = open(os.devnull, "wb")

#TSP values
TSP_SOCKET = "/tmp/socket.dvasion"
TSP_PREFIX = "TS_SOCKET=%s" % TSP_SOCKET

#Default values for cocurrent sample number (jobs) EEPs per run (procs) and timeout for the runs after the first one (time)
jobs = 4
procs = 10
time = 55

#Simply return the tsp queue 
def get_queue_state():
	try:	
		process = subprocess.check_output(["tsp"],env=dict(os.environ,TS_SOCKET=TSP_SOCKET))
		return process
	except Exception as e:
		print e
		print "Error while displaying queue status"
		sys.exit(1)
	return ""

def terminate_all_dvasion():
	TSPIDS = []
	process_list = get_queue_state()
	for line in process_list.splitlines():
		TSPIDS.append(line.split()[0])
	for tspid in TSPIDS:
		if ("ID" not in tspid):
			try:
				pid = subprocess.check_output(["tsp", "-p", tspid],env=dict(os.environ,TS_SOCKET=TSP_SOCKET))
				os.kill(int(pid),signal.SIGTERM)
			except Exception as e:
				print "Failed to retrieve PID for TSP job with id %s. Check TSP queue with command:" % tspid
				print "	python submit_dvasion.py -q"
	process = subprocess.Popen(["tsp","-K"],env=dict(os.environ,TS_SOCKET=TSP_SOCKET))




#Get the state of a task 
def get_task_state(task):
	tasklist=None
	try:	
		tasklist = subprocess.check_output(["tsp"],env=dict(os.environ,TS_SOCKET=TSP_SOCKET))
	except subprocess.CalledProcessError as e:
		print e
		print "Error while retrieving task status"

	found = False

	if (not tasklist == None):
		for x in tasklist.splitlines():
			if (task in x):
				tspid = (x.split())[0]
				try:			
					tspstatus = subprocess.check_output(["tsp","-s",tspid],env=dict(os.environ,TS_SOCKET=TSP_SOCKET))
				except subprocess.CalledProcessError as e:
					print e
					print "Error while retrieving task status"
				if (not tspstatus == None):
					print "Task \"%s\" with task spooler id \"%s\" status: %s" % (task,tspid,tspstatus.rstrip())
					found=True

	if (found == False):
		#Check to see if the report exists if the task is not in the task spooler task list
		#If the report does not exist, there must have been an error. Otherwise, the task is finished
		report_path = os.path.join(os.getcwd(), "reports", "dvasion", (task + ".report"))	
		if (not os.path.isfile(report_path)):
			print "Task \"%s\" could not be found.\nPlease check that this is the correct and try again, or resubmit the task" % task
		else:	
			print "Task \"%s\" status: finished. Report path: %s" % (task,report_path)	

		
	
#Parse the configuration file. Give an error if it does not exist, rather than running the configuration file.
#We must do this because of the requirements of the calculate.py script
def parse_config_file():
	global jobs, procs, time
	if (not os.path.isfile("./scripts/calculate/dvasion_config.conf")):
		print "dvasion_config.conf could not be found. Please run Dvasion_Installation.sh\nfrom the root of the cuckoo directory before running this script:"
		print "	bash Dvasion_Installation.sh"
		sys.exit(1)
	#Parse the file, split on space should provide the numbers
	with open("./scripts/calculate/dvasion_config.conf") as f:
		for line in f.readlines():
			if "JOBS:" in line:
				jobs = line.split()[1]
			elif "PROCESSES:" in line:
				procs = line.split()[1]
			elif "TIME:" in line:
				time = line.split()[1]

	return int(jobs), int(procs), int(time)

#Build the list associated with the dvasion command. Used for Popen command
def build_dvasion_command(malware_sample, command_args):
	global procs, time
	dvasion_command = ["./dvasion","--timeout-vm-rest","105","--file",malware_sample]
        if command_args:
            dvasion_command += command_args
	return dvasion_command

#Create the tsp socket and set the number in the queue. This should only be run if the custom dvasion tsp socket does not exist yet
def setup_tsp():
	global jobs,null
	try:
		process = subprocess.Popen(["tsp","-nfS",str(jobs)],stdout=null,stderr=null,env=dict(os.environ,TS_SOCKET=TSP_SOCKET))
		exit_c = process.wait()
	except Exception as e:
		print e
		print "Error running tsp setup! Error running %s -nfS %s" % (TSP_PREFIX,str(jobs))
		sys.exit(1)

#Check that TSP is installed on the system. Also call setup_tsp (as explained above)
def check_tsp():
	global TSP_SOCKET
	if (not os.path.isfile(TSP_SOCKET)):	
		setup_tsp()
	#Call a command and check the exit value to determine if tsp is installed
	process = subprocess.Popen("command -v tsp > /dev/null 2>&1",shell=True)
	exit_c = process.wait()
	#If it's not installed, give an error
	if (exit_c != 0):
		print "Thread Spooler is missing from this system.\n", \
		      "Please install Thread Spooler before running this script\n", \
		      "On a Debian based system you can install using the command:\n", \
		      "	sudo apt-get install task-spooler\n"
		sys.exit(1)

	# Test TSP. If there's a problem with TSP, return an error
	try:
                subprocess.check_output(["tsp"],env=dict(os.environ,TS_SOCKET=TSP_SOCKET))
        except subprocess.CalledProcessError as e:
                print e
                print "Error accessing TSP. Retrieved error message and code listed above. \n\n", \
		      "Errors are typically due to a permissions error invloving the task spooler socket\n", \
		      "on multi-user systems. Check that you have write and read permissions \n", \
		      "for this socket."
		sys.exit(1) 

#Run the dvasion command determined through build_dvasion_command
def run_dvasion(dvasion_command, malware_sample):
	global null
	#Build the tsp command, which calls the dvasion command
	command_list = ["tsp","-nf"] 
	command_list.extend(dvasion_command)
	#Run the tsp process	
	try:	
		process = subprocess.Popen(command_list,stdout=null,stderr=null,env=dict(os.environ,TS_SOCKET=TSP_SOCKET))
	except Exception as e:
		print e
		print "Error queuing task %s!" % malware_sample
		sys.exit(1)
	print "Running %s" % " ".join(dvasion_command)

	
#Argument parser
p = argparse.ArgumentParser()
p.add_argument("-f", "--file", type=str, help="The file or files that you would like to analyze", default=None)
p.add_argument("-q", "--queue_status", help="Check state of dvasion jobs queued", action='store_true')
p.add_argument("-t", "--task_status" , type=str, dest="task_to_check", help="Check state of given dvasion task", default=None)
p.add_argument("-k", "--kill_processes",help="Terminate All Running Dvasion Processes", action='store_true')
p.add_argument("-s", "--socket",help="Set the socket used by TSP. This needs to be a full path. Default is /tmp/socket.dvasion",dest="new_tspsocket")
p.add_argument("-o", "--options", nargs=argparse.REMAINDER,
        help="Options to pass to the dvasion utility. Must be the last argument when calling this script - everything following will go to dvasion!")
args = p.parse_args()

filename = args.file
check_tsp_state = args.queue_status
kill_processes = args.kill_processes
check_task_state = args.task_to_check

if (args.new_tspsocket):
	TSP_SOCKET = args.new_tspsocket
	TSP_PREFIX = "TS_SOCKET=%s" % TSP_SOCKET


#Force the script to run from the folder the file is in
script_path = os.path.dirname(os.path.realpath(__file__))
os.chdir(script_path)

#Get the values needed to run dvasion properly
jobs,procs,time = parse_config_file()

#Check that tsp is installed and is running correctly
check_tsp()

#If the user wants to terminate all of the processes on the list, simply do this and exit
if (kill_processes):
	terminate_all_dvasion()
	sys.exit(0)

#If the user didn't give a filename, fail
if (filename == None and check_tsp_state == False and check_task_state == False ):
	print "ERROR: Please include a file or folder to analyze using the -f or --file option"
	print "	python dvasion_submit.py -f [malware sample/folder]"
	sys.exit(1)

#Check if the sample is a file or a directory.
#If it's a file, we simply run it
#If it's a directory, loop through all the files in the directory and run them
#(Currently this is not recursive)
#If it's neither, this file probably does not exist, return an error message
if not (filename == None):
	if (os.path.isfile(filename)):
		run_dvasion(build_dvasion_command(filename, args.options),os.path.basename(filename))
	elif (os.path.isdir(filename)):
		for mal_sample in os.listdir(filename):
			run_dvasion(build_dvasion_command(os.path.join(filename,mal_sample), args.options),mal_sample)
	else:
		print "Error reading file. Check the filename and rerun this script."
		sys.exit(1)

if (check_tsp_state):
	print get_queue_state()
if (not check_task_state == None):
	get_task_state(check_task_state)

sys.exit(0)
