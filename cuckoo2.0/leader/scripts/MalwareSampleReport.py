'''
Created on Jul 13, 2016

@author: khaled
'''

import json

"""@class MalwareSample
Represents a malware sample through its cuckoo json report
"""
class MalwareSampleReport(object):
    '''
    This is a class representing a malware sample. It reads the json
    report and identifies some characteristics about the sample. The
    most important one is if the sample is evasive or not.
    '''

    
    def __init__(self, path):
        """
        Constructor
        """
        json_file = open (path, "r")
        self.report = json.load(json_file)
        self.sample_name = self.report['target']['file']['name']
        
    
    def get_sample_name(self):
        """Get the sample name from the report file"""
        return self.sample_name
    
    def set_malware_result(self,inVal):
	try:
		self.report['info']['result']=inVal
	except:
		return

    
    def get_score(self):
        """Returns the score cuckoo assigned to this sample"""
	try:
	        return self.report['info']['score']
	except:
		return 0   

    def set_score(self,newscore):
	#Sets the score with cap 10.0
	tempscore = newscore
	if tempscore > 10.0:
		tempscore = 10.0
	try:
		self.report['info']['score']=tempscore
	except:
		return
 
    
    def is_evasive(self):
        """Returns True if this sample is likely evasive"""
        if self.get_score() > 3.0:
            #print "Score is > 3.0"
            return False
        if self.get_num_relevant_sigs() > 3:
            #print "Num relevant signatures > 3"
            return False
        if self.get_num_unique_api_calls() > 40:
            #print "Num of unique API calls > 40"
            return False
        
        return True
    
    def get_num_unique_api_calls(self):
        """Returns the number of unique API calls called from this sample"""
        num = 0
        try:
            for process in self.report['behavior']['apistats']:
                apistats = self.report['behavior']['apistats'][process]
                num = num + (len(apistats.items()))
        
        except KeyError:
            return 0  
            
        return num
   
    def get_num_unique_api_for_process(self,pid):
	pidStr = str(pid)
	try:
		apistats = self.report["behavior"]["apistats"][pidStr]
		return len(apistats.items())
		#retur
		#for key,value in apistats.iteritems():
		#	print key
		#	if key == str(pid):
		#		return len(value)		
	except KeyError:
		print "Error in looking up: " + str(pid)
		return 0

 
    def add_signature(self,sig):
        self.report["signatures"].append(sig)

	#Update score as well
	#Get Existing score
 	curScore = float(self.get_score())
  
 	severityVal = float(sig['severity'])
 
	#Update score with cuckoo's formula
	newScore = curScore + (severityVal/5.0)
	newScore = round(newScore,1)
 
 	#Add it back to the report
	self.set_score(newScore)

 

    def mark_sig_as_new(self,sig):
	sig["new_vs_cuckoo"] = "True"     
    
    def dump_json_file(self,file_path):
        jsonFile = open(file_path, "w+")
        jsonFile.write(json.dumps(self.report,indent=4))
        
    
    @staticmethod
    def is_ignored_signature(sig):
        """Returns True if this is a static signature"""
        ignored_sigs = ["has_authenticode","antivirus_virustotal",
                        "packer_upx","network_icmp", "packer_entropy", 
                        "has_pdb", "pe_features", "raises_exception", 
                        "antisandbox_sleep"]
        if sig in ignored_sigs:
            return True
        else:
            return False

    def get_num_relevant_sigs(self):
        """"Count the number of signatures apart from severity one and static ones"""
        num = 0
        for s in self.report["signatures"]:
            severity = s["severity"]
            if severity == 1:
                #print "Ignoring severity 1 signature: " + str(s['description'])
                continue; #level 1 alerts do not count
            if MalwareSampleReport.is_ignored_signature(s["name"]):
                #print "Ignoring static signature: " + str(s['description'])
                continue; #static signatures do not count
            num = num + 1
    
        return num

    def get_num_of_non_ignored_sigs(self):
        """"Count the number of signatures apart from the static ones"""
        num = 0
        for s in self.report["signatures"]:
            if MalwareSampleReport.is_ignored_signature(s["name"]):
                #print "Ignoring static signature: " + str(s['description'])
                continue; #static signatures do not count
            
            num = num + 1
    
        return num
    
    def print_non_ignored_sigs(self):
        """"Prints the signatures apart from the static ones"""
        num = 0
        for s in self.report["signatures"]:
            if MalwareSampleReport.is_ignored_signature(s["name"]):
                #print "Ignoring static signature: " + str(s['description'])
                continue; #static signatures do not count
            
            print s["description"]
    
        return num
    
    def get_non_ignored_sigs(self):
        """"Returns a list of the signatures apart from the ignored ones"""
        ret = []
        for s in self.report["signatures"]:
            if MalwareSampleReport.is_ignored_signature(s["name"]):
                #print "Ignoring static signature: " + str(s['description'])
                continue; #static signatures do not count
            
            ret.append(s["name"])
    
        return ret
    
    def get_all_signatures(self):
	return self.report["signatures"]

    def has_apistats(self):
        try:
            s = self.report["behavior"]["apistats"]
            return True
        except KeyError:
            return False
    
    
    def get_all_pids(self):
        processes = self.report["processes"]
        retval = []
        for process in processes:
            try:
                retval.append(process["pid"])
            except KeyError:
                pass
        return retval
   
    def get_pid_for_process(self,processName):
	processes = self.report["behavior"]["processes"]
	
	try:
 		for process in processes:
			if processName in process["process_name"]:
				return process["pid"]
	except:
		return 0
		
	return 0
   

    def get_num_processes(self):
	processes = self.report["behavior"]["processes"]
	return len(processes)

    def get_process_tree(self):
	
	return self.report["behavior"]["processtree"]
 
    def get_root_pid(self):
        all_pids = self.get_all_pids()
        processes = self.report["processes"]
        for process in processes:
            try:
                pid = process["pid"]
                ppid = process["ppid"]
                name = process["process_name"]
                if self.sample_name in name:
                    if not (ppid in all_pids):
                        return pid
                
            except KeyError:
                pass
        
        return 0
        
	 
    
    def is_sig_in_pid(self, sig, pid):
        pids = self.get_pids_for_sig(sig)
        if pid in pids:
            return True
        else:
            return False
    
    
    def get_pids_for_sig(self, sig):
        retval = []
        for mark in sig["marks"]:
            try :
                retval.append(mark["pid"])
            except KeyError:
                pass
        return retval
  

    def update_pid_mark_in_sigs(self,pids,newpid):
	if newpid==0:
		return
	#Iterate through signatures. We only want to keep marks from
	#only one PID out of pids. That single one should be modified
	#to newpid
	try:
        	for s in self.report["signatures"]:
			extraMarkIndices=[]
			curIndex=-1
			markPID=""
			for mark in s["marks"]:
				if "pid" in mark:
					curpid = mark["pid"]
					curIndex=curIndex+1

					if markPID and str(curpid) != markPID: 
						extraMarkIndices.append(curIndex)
						continue
						
					#If we already have final pid, just keep that
					if str(newpid) == str(curpid):
						#print "Sig: " + s["name"] + " Mark alreay exists for " + str(newpid)
						markPID = str(curpid)
						continue

					#Otherwise, check if this pid matches any in the list
					for pid in pids:
						if str(curpid) == str(pid):
							#print "Sig:" + s["name"] + " Updating pid from " + str(curpid) + " to " + str(newpid) 
							markPID = str(curpid)
							mark["pid"]=str(newpid)
							break


			#Delete extra marks
			for index in sorted(extraMarkIndices,reverse=True):
				del s["marks"][index]
	except:
		print "Failed to update	sigs"
		
 
   
    def deleteBehaviorEntry(self,fieldName,pid):

	deleteIndex = 0
	behavior = self.report["behavior"]
	try:
		for process in behavior[fieldName]:	
			if process["pid"]==pid:
				del(self.report["behavior"][fieldName][deleteIndex])
				break
			deleteIndex=deleteIndex+1
        
	except:
		print "Failed to delete behavior for: " + str(pid)
	
    def deletePID(self,pid):
	#In order to delete a PID from report, we need to delete its entry from:
	# 1. behavior->processes
	# 2. behavior->generic
	# 3. behavior->apistats
	# This function does not update its entry in processtree, since the behavior
	# of its children becomes undefined. That should be taken care of separately.
	
	self.deleteBehaviorEntry("processes",pid)
	self.deleteBehaviorEntry("generic",pid) 	

	pidStr = str(pid)
	try:
		apistats = self.report["behavior"]["apistats"]
		if pidStr in apistats:
			del self.report["behavior"]["apistats"][pidStr]
	
	except:
		print "Failed to remove apistats for: " + pidStr

    def deleteProcFromProcTree(self,process_name):
	procTree = self.report["behavior"]["processtree"]	
	
	deleteIndex=0	
	#We only look for base processes
	try:
		for process in procTree:
			if process_name in  process["process_name"]:
				del self.report["behavior"]["processtree"][deleteIndex]
				break
			deleteIndex=deleteIndex+1
	except:
		print "Failed to find: " + process_name
	return None	

    def hasProcInProcTree(self,processName):
	try:
		procTree = self.report["behavior"]["processtree"]	
		for process in procTree:
			if processName in process["process_name"]:
				return True

		return False
	except:
		return False

    def addNewProcToProcTree(self,nodeList):
	for node in nodeList:
		self.report["behavior"]["processtree"].append(node)


    def buildNewProcTreeNode(self,process):
	newProc = dict()
	try:
		newProc["pid"]=process["pid"]
		newProc["ppid"]=process["ppid"]
		newProc["process_name"]=process["process_name"]
		newProc["children"]=[]
	except:
		pass
	return newProc

    def addProcToProcTree(self,procTree,process):
	added=False
	for proc in procTree:
		#Search for parent
		if proc["pid"]==process["ppid"]:
			#If we found parent, add it to the tree
			newProc=self.buildNewProcTreeNode(process)
			proc["children"].append(newProc)
			return True
		#Else search in children
		added = self.addProcToProcTree(proc["children"],process)	
		if added:
			break
	
	return added

    def build_proc_tree_from_pids(self):
	
	procTree = []
	processes = self.report["behavior"]["processes"]
	for process in processes:
		added = self.addProcToProcTree(procTree,process)	
		if not added:
			newProc = self.buildNewProcTreeNode(process)
			procTree.append(newProc)

	return procTree	
	
