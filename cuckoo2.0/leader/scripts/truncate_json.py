#!/usr/bin/python

import sys
from MalwareSampleReport import MalwareSampleReport


REWRITER_PROC = "dvasion_exp.exe"

#List of all merge IDs
listMergeIDs = []

#Map between PID and mergeIDs
pidMergeIDMap = dict()

#MergeIdentifier. To figure out which PIDs should be merged together
class MergeIdentifier:
	
    def __init__(self):
        self.processname = ""
        self.depth = 0
	self.childIndex = 0
	self.parentMergeID = 0
	self.curID = 0
	self.dominantPID = 0
        self.pids = []

    def haspid(inPid):
	if inPid in self.pids:
		return True
	else:
		return False
	

def getBaseProc(procTree,basePID):

	for process in procTree:
		if process["pid"]==basePID:
			return process
	return 

def getRewriterProc(procTree):
	for process in procTree:
		
		if REWRITER_PROC in process["process_name"]:
			return process

	#print "Rewriter process not found"
	return 


def getMergeID(pid):
	try:
		return pidMergeIDMap[pid]
	except:
		return 


def findPIDWithMaxAPI(listpids,report):
	maxAPI = -1
	pidVal = 0
	for pid in listpids:
		curAPI =  report.get_num_unique_api_for_process(pid)
		#print "Process: " + str(pid) + " NumAPI:" +  str(curAPI)
		if curAPI > maxAPI:
			maxAPI = curAPI
			pidVal = pid
	
	return pidVal	



def getEntry(curProc,depth,index):
	for mergeID in listMergeIDs:
		if (mergeID.processname == curProc["process_name"] and
		    mergeID.depth == depth and
		    mergeID.childIndex == index and
		    mergeID.parentMergeID == getMergeID(curProc["ppid"])):
			return mergeID
		
	parentID = 0
	if len(listMergeIDs) !=0 :
		parentID = getMergeID(curProc["ppid"])
		
	#No mergeID yet for this process, lets create one
	newMergeID = MergeIdentifier()
	newMergeID.processname = curProc["process_name"]
	newMergeID.depth=depth
	newMergeID.parentMergeID = parentID 
	newMergeID.childIndex = index
	newMergeID.curID = len(listMergeIDs)
	listMergeIDs.append(newMergeID)
	return newMergeID


def traverseProcTree(curProc,depth,index,basePid):
	children = curProc["children"]
	#We want to sort the children by process_name to avoid issues where
	#a particular process appers in a different order for different parents
	sortedChildren = sorted(children, key=lambda x: x["process_name"])
	curIndex=0
	for child in sortedChildren:
		#For children of dvasion_exp.exe, we would like to merge all
		#regardless of their order
		if child["ppid"] == basePid:
			curIndex = 0
		curMergeID = getEntry(child,depth,curIndex)
		curMergeID.pids.append(child["pid"])
		pidMergeIDMap[child["pid"]] = curMergeID.curID
		traverseProcTree(child,depth+1,curIndex,basePid)
		curIndex = curIndex+1
		

def determineMergePIDS(procTree,basePID):

	#Get to the node corresponding to dvasion_exp.exe
	baseProc = getRewriterProc(procTree)

	if baseProc == None:
		return
		
	#We basically need to replace this basenode with another node
	#in processtree after computation

	curEntry = getEntry(baseProc,0,0)	
	pidMergeIDMap[baseProc["pid"]] = curEntry.curID

	#Travese from this node and find out which PIDs must be merged
	traverseProcTree(baseProc,1,0,baseProc["pid"])
	
	

def getNodeWithoutChildren(procTree,pid):
	#Check if current node is the required one
	if procTree["pid"]==pid:
		newNode = dict(procTree) #Copy it instead of reference
		newNode["children"] = []
		return newNode

	#Otherwise, iterate over childre
	children = procTree["children"]
	for child in children:
		retval = getNodeWithoutChildren(child,pid)			
		if retval != None:
			return retval

	return None


def addNodeToTree(newRewriterProc,newNode,entry):
	#If first entry, just add
	if entry.parentMergeID==0:
		newRewriterProc.append(newNode)
		return True

	#Recursive iterate over processes
	for proc in newRewriterProc:
		#Check if current entry matches
		if proc["MergeID"]==entry.parentMergeID:
			#Add node as child
			proc["children"].append(newNode)	
			return True
		#Otherwise search for its children
		added = addNodeToTree(proc["children"],newNode,entry)
		if added==True:
			return True

	return False
			
	
def updateProcTree(sampleReport):
		
	origProcTree = sampleReport.get_process_tree()

	#RewriterProcess
	rewriterProc = getRewriterProc(origProcTree)

	#Create an empty process tree that will replace rewriter process
	#in processtree
	newRewriterProc = []

	#Loop over entries in list of MergePID
	for entry in listMergeIDs:
		#Skip rewriter process
		if entry.curID==0:
			continue

		#Get Node for its dominante PID
		newNode = getNodeWithoutChildren(rewriterProc,entry.dominantPID)

		if newNode == None:
			#print "Failed to get node for " + str(entry.dominantPID)
			break

		#print "Got Node For: " + str(entry.dominantPID)
		#Add temporary identifier to node
		newNode["MergeID"]=entry.curID
			
		addNodeToTree(newRewriterProc,newNode,entry)
		
	sampleReport.deleteProcFromProcTree(REWRITER_PROC)
	sampleReport.addNewProcToProcTree(newRewriterProc)


def mergePIDs(sampleReport):
	
	#We go through the PIDs and select the PID which has maximum
	#number of distint API calls. This method can be parallelized 
	#in future by going through PIDs two at a time and implemeting
	#in a mergeSort fashion. Currently, we are impelmenting in a 
	#serial manner
	deletePIDs=[]
	#Determine which PIDs must be deleted
        for entry in listMergeIDs:		
		#Here, we merge all these PIDS into one PID
		pidKeep = findPIDWithMaxAPI(entry.pids,sampleReport)

		#Store this PID in corresponding structure
		entry.dominantPID = pidKeep
		#print "DominantPID: " + str(pidKeep)

		for pid in entry.pids:
			if pid != pidKeep:
				deletePIDs.append(pid)
		
	#print "NumRemaining:" + str(len(listMergeIDs))
	#print "ToDelete: " + str(len(deletePIDs))
	#Delete them from the report
	for pid in deletePIDs:
		#print "Deleting PID: " + str(pid)
		sampleReport.deletePID(pid)


def truncate_json(inReportName,outReportName):

	#Read incomign report
	sampleReport = MalwareSampleReport(inReportName)

	hasProcTree = False
	curProcTree = []

	#Get PID for rewriter process
	rewriterPID = sampleReport.get_pid_for_process(REWRITER_PROC)
	if rewriterPID == 0:
		sampleReport.dump_json_file(outReportName)
		#print "No rewriter process. Not doing anything"
		return

	#print "Rewriter PID : " + str(rewriterPID)

	#Check if rewriter process is in proc tree
	if sampleReport.hasProcInProcTree(REWRITER_PROC):
		hasProcTree = True
	
		#Get Process Tree from malware sample
		curProcTree = sampleReport.get_process_tree()

	else:	
		#print "Failed to get rewriter PID in current report. Building process tree."
		curProcTree = sampleReport.build_proc_tree_from_pids()
			
	#Determine the PIDs which should be merged	
	determineMergePIDS(curProcTree,rewriterPID)
	
	#Dump traversal and merge info
        #for entry in listMergeIDs:
        	#print entry.processname + " ID:" + str(entry.curID) + " ParentID:" + str(entry.parentMergeID)
		#print "Depth: " + str(entry.depth) + " ChildIndex:" + str(entry.childIndex)
		#for pid in entry.pids:
		#	print pid		
		#pass
	
	#Merge the PIDs as determined above
	mergePIDs(sampleReport)

	#Update mark in sigs
        for entry in listMergeIDs:
		sampleReport.update_pid_mark_in_sigs(entry.pids, entry.dominantPID)
	
	#Update processtree if needed
	if hasProcTree:
		updateProcTree(sampleReport)

	#Delete rewriter PID
	sampleReport.deletePID(rewriterPID)


	sampleReport.dump_json_file(outReportName)
		

def main():
	
	inName = sys.argv[1]
	outName = sys.argv[2]
	
	
	truncate_json(inName,outName)
		
		


if __name__ == "__main__":main() 

