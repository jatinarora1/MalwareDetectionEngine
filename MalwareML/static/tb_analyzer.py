#!/usr/bin/env python3
import os
import sys
import json
import datetime
import argparse
import traceback
from collections import defaultdict

STATIC = 0
DYN = 1

def printd(*args, **kwargs):
    if args_dict['verbose']:
        print('{} || '.format(datetime.datetime.now()), end='')
        print(*args, **kwargs)

if __name__ == "__main__":
    programDescription = "Analyze malicious and benign thresholds for static analyzer to measure timeliness, bandwidth, and accuracy"

    parser = argparse.ArgumentParser(description=programDescription)

    #--Flags--
    parser.add_argument('static.results.json', help='Results from testing static ml tool (in JSON format)')
    parser.add_argument('dynamic.results.json', help='Results from testing dynamic ml tool (in JSON format)')
    parser.add_argument('truths.txt', help='File containing hash <0|1>. 0 for goodware, 1 for malware')
    parser.add_argument('-t1', '--threshold_1', help='Threshold 1. Determines what gets put into very benign bucket')
    parser.add_argument('-t2', '--threshold_2', help='Threshold 2. Determines what gets put into very malicious bucket')
    parser.add_argument('-ct', '--classifier_threshold', help='Threshold used for determining malware/goodware for {static,dynamic}-only analysis tool')
    parser.add_argument('-v', '--verbose', action='store_true', help='Print verbose output')
    
    args = parser.parse_args()
    args_dict = vars(args)

    if (not os.path.isfile(args_dict['static.results.json']) or not os.path.isfile(args_dict['dynamic.results.json'])
            or not os.path.isfile(args_dict['truths.txt'])):
        print('Necessary files do not exist')
        sys.exit()
    
    printd(args_dict)
    #Declare some variables
    results = [defaultdict(int), defaultdict(int)]
    truths = {}
    
    #Counts for how many malware/goodware are in each threshold bucket
    malware_buckets = [0,0,0]
    goodware_buckets = [0,0,0]

    #Thresholds
    if args_dict['classifier_threshold']:
        c_operating_threshold = float(args_dict.pop('classifier_threshold'))
    else:
        printd('Using default classifier_threshold of .5')
        c_operating_threshold = 0.5

    if args_dict['threshold_1']:
        t1 = float(args_dict.pop('threshold_1'))
    else:
        printd('Using default threshold_1 of 0.1')
        t1 = 0.1

    if args_dict['threshold_2']:
        t2 = float(args_dict.pop('threshold_2'))
    else:
        printd('Using default threshold_2 of 0.9')
        t2 = 0.9
    
    #Total Counts
    total_goodware = 0
    total_malware = 0

    #--Load truth files--
    with open(args_dict.pop('truths.txt')) as f:
        for line in f:
            line = line.rstrip()
            if len(line.split(' ')) != 2:
                print('truths.txt does not have proper format. Check line {}'.format(total_goodware+total_malware+1))
                sys.exit()
            truths[line.split(' ')[0]] = int(line.split(' ')[1])
            if int(line.split(' ')[1]) == 0:
                total_goodware += 1
            else:
                total_malware += 1
    printd('Total programs found in truths.txt: {}\n\tGoodware: {}\n\tMalware: {}'.format(total_goodware+total_malware, total_goodware, total_malware))
    
    #--Load result json files--
    try:
        with open(args_dict.pop('static.results.json')) as f:
            results_dict_s = json.load(f)
    except json.JSONDecodeError:
        printd('Error parsing report for {}'.format(results[STATIC]))
        sys.exit()

    try:
        with open(args_dict.pop('dynamic.results.json')) as f:
            results_dict_d = json.load(f)        
    except json.JSONDecodeError:
        printd('Error parsing report for {}'.format(results[STATIC]))
        sys.exit()


    #--Parse results--

    #Variables to track dynamic accuracy
    acc_dyn_g = 0
    acc_dyn_m = 0

    #Variable to track # of alerts from dynamic/static tool
    alerts_static = 0
    alerts_static_g = 0
    alerts_hybrid = 0
    alerts_hybrid_g = 0
    alerts_dyn = 0
    alerts_dyn_g = 0

    #Keeps track of dynamic predictions. 1 means dynamic got a sample k correct. 0 is wrong
    dyn_predictions = {}
    
    for k, v in results_dict_d.items():
        #Should check to make sure current item in result exists in truth...
        if v['prediction'][1] <= c_operating_threshold:
            if truths[k] == 0:
                acc_dyn_g += 1
                dyn_predictions[k] = 1
            else:
                dyn_predictions[k] = 0
        elif v['prediction'][1] > c_operating_threshold:
            alerts_dyn += 1
            if truths[k] == 1:
                acc_dyn_m += 1
                dyn_predictions[k] = 1
            else:
                dyn_predictions[k] = 0
                alerts_dyn_g += 1

    #Variables to keep track of accuracy in bucket 2 when using dynamic tool
    #TODO: Can optimize out I think?
    acc_bucket2_g = 0
    acc_bucket2_m = 0

    #Variables to keep track of overall accuracy of static classifier
    acc_static_g = 0
    acc_static_m = 0

    static_total = 0
    static_missed = 0
    #Iterate through the static results
    for k, v in results_dict_s.items():
        static_total += 1
        #Should check to make sure current item in result exists in truth...
        if k not in truths:
            static_missed += 1
            continue

        #TODO: Can optimize later
        if v['prediction'][1] <= c_operating_threshold:
            if truths[k] == 0:
                acc_static_g += 1
        elif v['prediction'][1] > c_operating_threshold:
            alerts_static += 1
            if truths[k] == 1:
                acc_static_m += 1
            else:
                alerts_static_g += 1
        #Calculate the splits between the buckets and accuracy each bucket
        #Bucket 1
        if v['prediction'][1] <= t1:
            if truths[k] == 0:
                goodware_buckets[0] += 1
            else:
                malware_buckets[0] += 1
        #Bucket 2
        elif v['prediction'][1] <= t2:
            if truths[k] == 0:
                goodware_buckets[1] += 1
            else:
                malware_buckets[1] += 1
            if k not in dyn_predictions:
                if v['prediction'][1] <= c_operating_threshold:
                    if truths[k] == 0:
                        acc_bucket2_g += 1
                else:
                    if truths[k] == 1:
                        acc_bucket2_m += 1
                        alerts_hybrid += 1
                continue
            if dyn_predictions[k] == 1:
                if truths[k] == 0:
                    acc_bucket2_g += 1
                else:
                    acc_bucket2_m += 1
                    alerts_hybrid += 1
            else:
                if truths[k] == 0:
                    alerts_hybrid_g += 1
                    alerts_hybrid += 1
        #Bucket 3
        elif v['prediction'][1] <= 1:
            if truths[k] == 0:
                goodware_buckets[2] += 1
            else:
                malware_buckets[2] += 1

    print('Total: {} Missed: {}'.format(static_total,static_missed))
    print('For t1 = {} and t2 = {}:'.format(t1, t2))
    print('Number of goodware not run: {} ({}%)'.format(goodware_buckets[0], float(goodware_buckets[0]/total_goodware)*100))
    print('BW now needed: {}%'.format((float(1) - float(goodware_buckets[0]+goodware_buckets[2]+malware_buckets[2]+malware_buckets[0])/float(total_goodware+total_malware))*100))
    print('# of malware stopped: {} ({}%)'.format(malware_buckets[2], float(malware_buckets[2]/total_malware)*100))
    print('Accuracy of only dynamic tool with op_threshold = {}: {}%\n\tGoodware: {}%\n\tMalware: {}%'.format(c_operating_threshold,
                                                                                                              100*(float(acc_dyn_m+acc_dyn_g)/float(total_goodware+total_malware)),
                                                                                                              100*(float(acc_dyn_g/total_goodware)),
                                                                                                              100*(float(acc_dyn_m/total_malware))))
    print('# of alerts from only dynamic tool: {}'.format(alerts_dyn))
    print('Accuracy of only static tool with op_threshold = {}: {}%\n\tGoodware: {}%\n\tMalware: {}%'.format(c_operating_threshold,
                                                                                                              100*(float(acc_static_m+acc_static_g)/float(total_goodware+total_malware)),
                                                                                                              100*(float(acc_static_g/total_goodware)),
                                                                                                              100*(float(acc_static_m/total_malware))))
    print('# of alerts from only static tool: {}'.format(alerts_static))
    print('Distribution in Bucket 1: malware: {} ({}%) goodware: {} ({}%)'.format(malware_buckets[0], 100*float(malware_buckets[0]/total_malware),
                                                                                  goodware_buckets[0], 100*float(goodware_buckets[0]/total_goodware)))
    print('Distribution in Bucket 2: malware: {} ({}%) goodware: {} ({}%)'.format(malware_buckets[1], 100*float(malware_buckets[1]/total_malware),
                                                                                  goodware_buckets[1], 100*float(goodware_buckets[1]/total_goodware)))
    print('Distribution in Bucket 3: malware: {} ({}%) goodware: {} ({}%)'.format(malware_buckets[2], 100*float(malware_buckets[2]/total_malware),
                                                                                  goodware_buckets[2], 100*float(goodware_buckets[2]/total_goodware)))
    print('Accuracy of static + dynamic tool: {}%\n\tGoodware: {}%\n\tMalware: {}%'.format((float(goodware_buckets[0]+malware_buckets[2]+acc_bucket2_g+acc_bucket2_m)/
                                                                                            float(total_goodware+total_malware))*100,
                                                                                           (float(goodware_buckets[0]+acc_bucket2_g)/float(total_goodware))*100,
                                                                                           (float(malware_buckets[2]+acc_bucket2_m)/float(total_malware))*100))
    print('Accuracy of Bucket 1: {}%'.format(float(goodware_buckets[0]/(goodware_buckets[0]+malware_buckets[0])*100)))
    print('Accuracy of Bucket 2: {}\n\tGoodware: {}%\n\tMalware: {}%'.format((float(acc_bucket2_g+acc_bucket2_m)/float(goodware_buckets[1]+malware_buckets[1]))*100,
                                                                             float(acc_bucket2_g/goodware_buckets[1])*100, float(acc_bucket2_m/malware_buckets[1])*100))
    print('Accuracy of Bucket 3: {}%'.format(float(malware_buckets[2]/(goodware_buckets[2]+malware_buckets[2])*100)))
    print('# of alerts from static dynamic tool: {}\n\tGoodware: {}'.format(alerts_hybrid, alerts_hybrid_g))
    print('% of alerts compared to dynamic: {}%'.format(float((alerts_hybrid_g*99)+(alerts_hybrid-alerts_hybrid_g))/float((alerts_dyn_g*99)+(alerts_dyn-alerts_dyn_g))*100))
    #How many alerts are we avoiding as well?
    #This static and dynamic tool is a hybrid passive and active tool as well.
    #% of alerts we are not getting anymore
